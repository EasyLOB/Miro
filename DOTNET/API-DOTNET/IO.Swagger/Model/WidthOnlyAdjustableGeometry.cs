/* 
 * Platform
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Contains geometrical information about the item, such as its width or rotation. You can only specify the width of the text item as the height is dynamically updated based on the content.
    /// </summary>
    [DataContract]
        public partial class WidthOnlyAdjustableGeometry :  IEquatable<WidthOnlyAdjustableGeometry>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="WidthOnlyAdjustableGeometry" /> class.
        /// </summary>
        /// <param name="rotation">Rotation angle of an item, in degrees, relative to the board. You can rotate items clockwise (right) and counterclockwise (left) by specifying positive and negative values, respectively..</param>
        /// <param name="width">Width of the item, in pixels.  The minimum &#x60;width&#x60; of a &#x60;text&#x60; widget is relative to the font size of the &#x60;text&#x60; widget. The width must be at least 1.7 times wider than the font size. For example, if the font size of the &#x60;text&#x60; item is &#x60;14&#x60;, the minimum &#x60;width&#x60; is &#x60;24&#x60;..</param>
        public WidthOnlyAdjustableGeometry(double? rotation = default(double?), double? width = default(double?))
        {
            this.Rotation = rotation;
            this.Width = width;
        }
        
        /// <summary>
        /// Rotation angle of an item, in degrees, relative to the board. You can rotate items clockwise (right) and counterclockwise (left) by specifying positive and negative values, respectively.
        /// </summary>
        /// <value>Rotation angle of an item, in degrees, relative to the board. You can rotate items clockwise (right) and counterclockwise (left) by specifying positive and negative values, respectively.</value>
        [DataMember(Name="rotation", EmitDefaultValue=false)]
        public double? Rotation { get; set; }

        /// <summary>
        /// Width of the item, in pixels.  The minimum &#x60;width&#x60; of a &#x60;text&#x60; widget is relative to the font size of the &#x60;text&#x60; widget. The width must be at least 1.7 times wider than the font size. For example, if the font size of the &#x60;text&#x60; item is &#x60;14&#x60;, the minimum &#x60;width&#x60; is &#x60;24&#x60;.
        /// </summary>
        /// <value>Width of the item, in pixels.  The minimum &#x60;width&#x60; of a &#x60;text&#x60; widget is relative to the font size of the &#x60;text&#x60; widget. The width must be at least 1.7 times wider than the font size. For example, if the font size of the &#x60;text&#x60; item is &#x60;14&#x60;, the minimum &#x60;width&#x60; is &#x60;24&#x60;.</value>
        [DataMember(Name="width", EmitDefaultValue=false)]
        public double? Width { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class WidthOnlyAdjustableGeometry {\n");
            sb.Append("  Rotation: ").Append(Rotation).Append("\n");
            sb.Append("  Width: ").Append(Width).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as WidthOnlyAdjustableGeometry);
        }

        /// <summary>
        /// Returns true if WidthOnlyAdjustableGeometry instances are equal
        /// </summary>
        /// <param name="input">Instance of WidthOnlyAdjustableGeometry to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(WidthOnlyAdjustableGeometry input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Rotation == input.Rotation ||
                    (this.Rotation != null &&
                    this.Rotation.Equals(input.Rotation))
                ) && 
                (
                    this.Width == input.Width ||
                    (this.Width != null &&
                    this.Width.Equals(input.Width))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Rotation != null)
                    hashCode = hashCode * 59 + this.Rotation.GetHashCode();
                if (this.Width != null)
                    hashCode = hashCode * 59 + this.Width.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
